# Реализовывайте поддержку внесения JWT в черный список

### Объяснение в один абзац

По своей сути JWT (веб-токены JSON) полностью не сохраняют состояния, поэтому после того, как эмитент подписал действительный токен, токен может быть проверен приложением как аутентичный. Проблема, к которой это приводит - это проблема безопасности, когда утечка токена все еще может быть использована и не может быть отозвана из-за того, что подпись остается в силе до тех пор, пока подпись, предоставленная проблемами, совпадает с ожидаемой приложением.
В связи с этим при использовании аутентификации JWT приложение должно управлять черным списком токенов с истекшим сроком действия или отозванными токенами, чтобы сохранить безопасность пользователя в случае, если токен необходимо отозвать.

### `express-jwt-blacklist` пример

Пример запуска `express-jwt-blacklist` в проекте Node.js с использованием `express-jwt`. Обратите внимание, что важно не использовать кэш настроек хранилища по умолчанию (in-memory) `express-jwt-blacklist`, а использовать внешнее хранилище, такое как Redis, для отзыва токенов во многих процессах Node.js.

```javascript
const jwt = require('express-jwt');
const blacklist = require('express-jwt-blacklist');

blacklist.configure({
  tokenId: 'jti',
  strict: true,
  store: {
    type: 'memcached',
    host: '127.0.0.1',
    port: 11211,
    keyPrefix: 'mywebapp:',
    options: {
      timeout: 1000
    }
  }
});
 
app.use(jwt({
  secret: 'my-secret',
  isRevoked: blacklist.isRevoked
}));
 
app.get('/logout', (req, res)=> {
  blacklist.revoke(req.user)
  res.sendStatus(200);
});
```

### Что говорят другие блогеры

Из блога [Marc Busqué](http://waiting-for-dev.github.io/blog/2017/01/25/jwt_secure_usage/):
> ... добавить слой отзыва поверх JWT, даже если это подразумевает потерю своего состояния без состояния.
